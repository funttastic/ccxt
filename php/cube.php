<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\abstract\cube as Exchange;

class cube extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'cube',
            'name' => 'cube',
            'countries' => array(),
            'urls' => array(
                'referral' => 'https://cube.exchange/refer/yEUAbF',
                'logo' => 'https://github.com/ccxt/ccxt/assets/43336371/3aa748b7-ea44-45e9-a9e7-b1d207a2578a',
                'api' => array(
                    'rest' => array(
                        'production' => array(
                            'iridium' => 'https://api.cube.exchange/ir/v0',
                            'mendelev' => 'https://api.cube.exchange/md/v0',
                            'osmium' => 'https://api.cube.exchange/os/v0',
                        ),
                        'staging' => array(
                            'iridium' => 'https://staging.cube.exchange/ir/v0',
                            'mendelev' => 'https://staging.cube.exchange/md/v0',
                            'osmium' => 'https://staging.cube.exchange/os/v0',
                        ),
                    ),
                    'ws' => array(
                        'production' => array(
                            'iridium' => 'wss://api.cube.exchange/ir',
                            'mendelev' => 'wss://api.cube.exchange/md',
                            'osmium' => 'wss://api.cube.exchange/os',
                        ),
                        'staging' => array(
                            'iridium' => 'wss://staging.cube.exchange/ir',
                            'mendelev' => 'wss://staging.cube.exchange/md',
                            'osmium' => 'wss://staging.cube.exchange/os',
                        ),
                    ),
                ),
                'www' => 'https://www.cube.exchange/',
                'doc' => 'https://cubexch.gitbook.io/cube-api',
                'fees' => 'https://www.cube.exchange/fees',
            ),
            'version' => 'v0',
            'api' => array(
                'rest' => array(
                    'iridium' => array(
                        'public' => array(
                            'get' => array(
                                '/markets' => 1,
                            ),
                        ),
                        'private' => array(
                            'get' => array(
                                '/users/check' => 1,
                                '/users/info' => 1,
                                '/users/positions' => 1,
                                '/users/transfers' => 1,
                                '/users/deposits' => 1,
                                '/users/withdrawals' => 1,
                                '/users/subaccount/{subaccountId}/orders' => 1,
                                '/users/subaccount/{subaccountId}/fills' => 1,
                                '/users/fee-estimate/{market_id}' => 1,
                            ),
                            'post' => array(
                                '/users/subaccounts' => 1,
                                '/users/subaccounts/{subaccount_id}' => 1,
                                '/users/subaccounts/{subaccount_id}/withdrawals' => 1,
                            ),
                        ),
                    ),
                    'mendelev' => array(
                        'public' => array(
                            'get' => array(
                                '/book/{market_id}/snapshot' => 1,
                                '/parsed/book/{market_symbol}/snapshot' => 1,
                                '/book/{market_id}/recent-trades' => 1,
                                '/parsed/book/{market_symbol}/recent-trades' => 1,
                                '/tickers/snapshot' => 1,
                                '/parsed/tickers' => 1,
                            ),
                        ),
                    ),
                    'osmium' => array(
                        'private' => array(
                            'get' => array(
                                '/orders' => 1,
                            ),
                            'delete' => array(
                                '/orders' => 1,
                                '/order' => 1,
                            ),
                            'post' => array(
                                '/order' => 1,
                            ),
                            'patch' => array(
                                '/order' => 1,
                            ),
                        ),
                    ),
                ),
            ),
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => false,
                'swap' => true,
                'future' => false,
                'option' => false,
                'addMargin' => false,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'cancelOrders' => false,
                'closeAllPositions' => false,
                'closePosition' => false,
                'createDepositAddress' => false,
                'createMarketOrder' => false,
                'createOrder' => true,
                'createOrders' => false,
                'createPostOnlyOrder' => false,
                'createReduceOnlyOrder' => false,
                'createStopLimitOrder' => false,
                'createStopMarketOrder' => false,
                'createStopOrder' => false,
                'fetchAccounts' => true,
                'fetchBalance' => true,
                'fetchBorrowInterest' => false,
                'fetchBorrowRateHistory' => false,
                'fetchCanceledOrders' => false,
                'fetchClosedOrders' => false,
                'fetchCrossBorrowRate' => false,
                'fetchCrossBorrowRates' => false,
                'fetchCurrencies' => true,
                'fetchDeposit' => false,
                'fetchDepositAddress' => false,
                'fetchDepositAddresses' => false,
                'fetchDepositAddressesByNetwork' => false,
                'fetchDeposits' => false,
                'fetchDepositsWithdrawals' => false,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchIsolatedBorrowRate' => false,
                'fetchIsolatedBorrowRates' => false,
                'fetchLedger' => false,
                'fetchLedgerEntry' => false,
                'fetchLeverageTiers' => false,
                'fetchMarketLeverageTiers' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => false,
                'fetchOHLCV' => 'emulated',
                'fetchOpenInterest' => false,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrderBooks' => false,
                'fetchOrders' => false,
                'fetchOrderTrades' => false,
                'fetchPermissions' => false,
                'fetchPosition' => false,
                'fetchPositions' => false,
                'fetchPositionsForSymbol' => false,
                'fetchPositionsRisk' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchStatus' => false,
                'fetchTicker' => true,
                'fetchTickers' => false,
                'fetchTrades' => true,
                'fetchTradingFee' => true,
                'fetchTradingLimits' => false,
                'fetchTransactionFee' => false,
                'fetchTransactionFees' => false,
                'fetchTransactions' => false,
                'fetchTransfers' => false,
                'fetchWithdrawAddresses' => false,
                'fetchWithdrawal' => false,
                'fetchWithdrawals' => false,
                'reduceMargin' => false,
                'setLeverage' => false,
                'setMargin' => false,
                'setMarginMode' => false,
                'setPositionMode' => false,
                'signIn' => false,
                'transfer' => false,
                'withdraw' => false,
            ),
            'timeframes' => array(
                '1m' => '1minute',  // TODO => Update this to be the same UI
                '1h' => '1hour',
                '1d' => '1day',
                '1M' => '1month',
                '1y' => '1year',
            ),
            'timeout' => 10000,
            'rateLimit' => 100,
            'userAgent' => false,
            'verbose' => false,
            'markets' => null,
            'symbols' => null,
            'currencies' => null,
            'markets_by_id' => null,
            'currencies_by_id' => null,
            'apiKey' => '',
            'secret' => '',
            'password' => '',
            'uid' => '',
            'options' => array(
                'environment' => 'production',
                'subaccountId' => null,
                'networks' => array(
                    'BTC' => '1',
                    'ERC20' => '2',
                    'SPL' => '3',
                    'DOGE' => '4',
                    'TAO' => '5',
                    'LTC' => '6',
                    'tBTC' => '7',
                    'tETH' => '8',
                ),
                'impliedNetworks' => array(
                    'ETH' => array( 'ERC20' => '2' ),
                    'SOL' => array( 'SPL' => '3' ),
                ),
                'legalMoney' => array(
                    'USD' => true,
                ),
            ),
            'pro' => false,
            'fees' => array(
                'trading' => array(
                    'maker' => $this->parse_number('0.0004'),
                    'taker' => $this->parse_number('0.0008'),
                ),
            ),
            'commonCurrencies' => null,
            'precisionMode' => DECIMAL_PLACES,
            'exceptions' => array(
                'exact' => array(
                    'Must be authorized' => '\\ccxt\\AuthenticationError',
                    'Market not found' => '\\ccxt\\BadRequest',
                    'Insufficient funds' => '\\ccxt\\InsufficientFunds',
                    'Order not found' => '\\ccxt\\BadRequest',  // TODO => Add missing errors
                ),
            ),
        ));
    }

    public function generate_signature(): mixed {
        $timestamp = (int) floor($this->seconds());
        $timestampBuffer = $this->number_to_le($timestamp, 4);
        $fixedString = utf8ToBytes ('cube.xyz');
        $payload = $this->binary_concat_array(array( $fixedString, $timestampBuffer ));
        $secretKeyBytes = hexToBytes ($this->secret);
        $hmac = $this->hmac($payload, $secretKeyBytes, 'sha256', 'binary');
        $signatureB64 = Buffer.from ($hmac).toString ('base64');
        return array( $signatureB64, $timestamp );
    }

    public function generate_authentication_headers() {
        list($signature, $timestamp) = $this->generate_signature();
        return array(
            'x-api-key' => $this->apiKey,
            'x-api-signature' => $signature,
            'x-api-timestamp' => (string) $timestamp,
        );
    }

    public function authenticate_request(array $request): mixed {
        $headers = $this->safe_dict($request, 'headers', array());
        $request['headers'] = array_merge($headers, $this->generate_authentication_headers());
        return $request;
    }

    public function sign(string $path, array $api = [], ?string $method = 'GET', mixed $params = array (), mixed $headers = null, mixed $body = null) {
        $environment = $this->options['environment'];
        $baseUrl = $this->urls['www'];
        if ($this->in_array('iridium', $api)) {
            $baseUrl = $this->urls['api']['rest'][$environment]['iridium'];
        } elseif ($this->in_array('mendelev', $api)) {
            $baseUrl = $this->urls['api']['rest'][$environment]['mendelev'];
        } elseif ($this->in_array('osmium', $api)) {
            $baseUrl = $this->urls['api']['rest'][$environment]['osmium'];
        }
        $url = $baseUrl . $this->implode_params($path, $params);
        $params = $this->omit($params, $this->extract_params($path));
        if ($this->in_array($method, array( 'GET', 'HEAD' ))) {
            if ($params) {
                $url .= '?' . $this->urlencode($params);
            }
        } else {
            $body = json_encode ($params);
        }
        if ($this->in_array('private', $api)) {
            $request = array(
                'headers' => array(
                    'Content-Type' => 'application/json',
                    'Referer' => 'CCXT',
                ),
            );
            $request = $this->authenticate_request($request);
            $headers = $request['headers'];
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function set_sandbox_mode($enable) {
        if ($enable === true) {
            $this->options['environment'] = 'staging';
        } else {
            $this->options['environment'] = 'production';
        }
    }

    public function fetch_market_meta(mixed $symbolOrSymbols = null) {
        $symbol = null;
        $marketId = null;
        $market = null;
        $symbols = null;
        $marketIds = null;
        $markets = null;
        $this->load_markets();
        if ($symbolOrSymbols !== null) {
            if (gettype($symbolOrSymbols) === 'string') {
                $marketId = str_replace('/', '', strtoupper($symbolOrSymbols));
                $market = $this->market($marketId);
                $marketId = $market['id'];
                $symbolOrSymbols = $this->safe_symbol($marketId, $market);
                $symbol = $symbolOrSymbols;
                return array(
                    'symbol' => $symbol,
                    'marketId' => $marketId,
                    'market' => $market,
                    'symbols' => $symbols,
                    'marketIds' => $marketIds,
                    'markets' => $markets,
                );
            } elseif (gettype($symbolOrSymbols) === 'array' && array_keys($symbolOrSymbols) === array_keys(array_keys($symbolOrSymbols))) {
                $marketIds = array();
                $markets = array();
                for ($i = 0; $i < count($symbolOrSymbols); $i++) {
                    $marketId = str_replace('/', '', strtoupper($symbolOrSymbols[$i]));
                    $market = $this->market($marketId);
                    $marketId = $market['id'];
                    $symbolOrSymbols[$i] = $this->safe_symbol($marketId, $market);
                    $marketIds[] = $marketId;
                    $markets[] = $market;
                }
                $symbolOrSymbols = $this->market_symbols($symbolOrSymbols);
                $symbols = $symbolOrSymbols;
                return array(
                    'symbol' => $symbol,
                    'marketId' => $marketId,
                    'market' => $market,
                    'symbols' => $symbols,
                    'marketIds' => $marketIds,
                    'markets' => $markets,
                );
            } else {
                throw new BadSymbol($this->id . ' $symbolOrSymbols must be a string or an array of strings');
            }
        }
        return array(
            'symbol' => $symbol,
            'marketId' => $marketId,
            'market' => $market,
            'symbols' => $symbols,
            'marketIds' => $marketIds,
            'markets' => $markets,
        );
    }

    public function inject_sub_account_id($request, $params) {
        if ($this->safe_integer($params, 'subaccountId') !== null) {
            $request['subaccountId'] = $this->safe_integer($params, 'subaccountId');
        } elseif ($this->safe_integer($params, 'subAccountId') !== null) {
            $request['subaccountId'] = $this->safe_integer($params, 'subAccountId');
        } elseif ($this->safe_integer($this->options, 'subaccountId') !== null) {
            $request['subaccountId'] = $this->safe_integer($this->options, 'subaccountId');
        } elseif ($this->safe_integer($this->options, 'subAccountId') !== null) {
            $request['subaccountId'] = $this->safe_integer($this->options, 'subAccountId');
        }
    }

    public function fetch_currencies($params = array ()) {
        /**
         * fetches all available currencies on an exchange
         * @see https://cubexch.gitbook.io/cube-api/rest-iridium-api#markets
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an associative dictionary of currencies
         */
        $response = $this->restIridiumPublicGetMarkets ($params);
        // {
        //     "result" => {
        //         "assets" => array(
        //             array(
        //                 "assetId" => 1,
        //                 "symbol" => "BTC",
        //                 "decimals" => 8,
        //                 "displayDecimals" => 5,
        //                 "settles" => true,
        //                 "assetType" => "Crypto",
        //                 "sourceId" => 1,
        //                 "metadata" => array(
        //                     "dustAmount" => 3000
        //                 ),
        //                 "status" => 1
        //             ),
        //             ...
        //         ),
        //         ...
        //     }
        // }
        $assets = $this->safe_list($this->safe_dict($response, 'result'), 'assets');
        return $this->parse_currencies($assets);
    }

    public function parse_currencies(List $assets): array {
        $result = array();
        for ($i = 0; $i < count($assets); $i++) {
            $rawCurrency = $assets[$i];
            $symbol = $this->safe_string_upper($rawCurrency, 'symbol');
            $assetId = $this->safe_string($rawCurrency, 'assetId');
            $name = $this->safe_string($this->safe_dict($rawCurrency, 'metadata'), 'currencyName');
            $networkId = $this->safe_string($rawCurrency, 'sourceId');
            $networks = array();
            $networks[$networkId] = $this->safe_string($this->options['networks'], $networkId);
            $currency = $this->safe_currency_structure(array(
                'info' => $rawCurrency,
                'id' => $symbol,
                'numericId' => $this->safe_integer($rawCurrency, 'assetId'),
                'code' => $symbol,
                'precision' => $this->safe_integer($rawCurrency, 'decimals'),
                'type' => $this->safe_string_lower($rawCurrency, 'assetType'),
                'name' => $name,
                'active' => $this->safe_integer($rawCurrency, 'status') === 1,
                // TODO => Find out what status numbers there are
                'deposit' => null,
                // These flags determine if the $currency can be deposited or withdrawn
                'withdraw' => null,
                // TODO => What kind of fee is this?
                'fee' => null,
                'fees' => array(),
                'networks' => $networks,
                'limits' => array(
                    'deposit' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'withdraw' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
            ));
            $result[$assetId] = $currency;
        }
        return $result;
    }

    public function fetch_markets($params = array ()): array {
        /**
         * retrieves data on all markets for cube
         * @see https://cubexch.gitbook.io/cube-api/rest-iridium-api#markets
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} an array of objects representing market data
         */
        $response = $this->restIridiumPublicGetMarkets ($params);
        // {
        //     "result" => {
        //         "assets" => array(
        //             array(
        //                 "assetId" => 1,
        //                 "symbol" => "BTC",
        //                 "decimals" => 8,
        //                 "displayDecimals" => 5,
        //                 "settles" => true,
        //                 "assetType" => "Crypto",
        //                 "sourceId" => 1,
        //                 "metadata" => array(
        //                     "dustAmount" => 3000
        //                 ),
        //                 "status" => 1
        //             ),
        //             ...
        //         ),
        //         "markets" => array(
        //             array(
        //                 "marketId" => 100004,
        //                 "symbol" => "BTCUSDC",
        //                 "baseAssetId" => 1,
        //                 "baseLotSize" => "1000",
        //                 "quoteAssetId" => 7,
        //                 "quoteLotSize" => "1",
        //                 "priceDisplayDecimals" => 2,
        //                 "protectionPriceLevels" => 3000,
        //                 "priceBandBidPct" => 25,
        //                 "priceBandAskPct" => 400,
        //                 "priceTickSize" => "0.1",
        //                 "quantityTickSize" => "0.00001",
        //                 "status" => 1,
        //                 "feeTableId" => 2
        //             ),
        //             ...
        //         ),
        //         "feeTables" => array(
        //             {
        //                 "feeTableId" => 1,
        //                 "feeTiers" => array(
        //                     array(
        //                         "priority" => 0,
        //                         "makerFeeRatio" => 0.0,
        //                         "takerFeeRatio" => 0.0
        //                     }
        //                 )
        //             ),
        //             {
        //                 "feeTableId" => 2,
        //                 "feeTiers" => array(
        //                     {
        //                         "priority" => 0,
        //                         "makerFeeRatio" => 0.0004,
        //                         "takerFeeRatio" => 0.0008
        //                     }
        //                 )
        //             }
        //         )
        //     }
        // }
        $result = $this->safe_dict($response, 'result');
        $rawMarkets = $this->safe_list($result, 'markets');
        $rawAssets = $this->safe_list($result, 'assets');
        $this->currencies = $this->parse_currencies($rawAssets);
        return $this->parse_markets($rawMarkets);
    }

    public function parse_markets(array $markets): array {
        $result = array();
        for ($i = 0; $i < count($markets); $i++) {
            $market = $this->parse_market($markets[$i]);
            $result[] = $market;
        }
        return $result;
    }

    public function parse_market(array $market): array {
        $id = $this->safe_string_lower($market, 'symbol');
        $symbol = strtoupper($id);
        $baseAssetId = $this->safe_string($market, 'baseAssetId');
        $baseAsset = $this->safe_dict($this->currencies, $baseAssetId);
        $quoteAssetId = $this->safe_string($market, 'quoteAssetId');
        $quoteAsset = $this->safe_dict($this->currencies, $quoteAssetId);
        $base = $this->safe_string_upper($baseAsset, 'id');
        $quote = $this->safe_string_upper($quoteAsset, 'id');
        $baseId = strtolower($base);
        $quoteId = strtolower($quote);
        return $this->safe_market_structure(array(
            'id' => $id,
            'lowercaseId' => strtolower($id),
            'symbol' => $symbol,
            'base' => $base,
            'quote' => $quote,
            'settle' => null,
            'baseId' => $baseId,
            'quoteId' => $quoteId,
            'settleId' => null,
            'type' => 'spot',
            'spot' => true,
            'margin' => false,
            'swap' => false,
            'future' => false,
            'option' => false,
            'active' => $this->safe_integer($market, 'status') === 1,
            'contract' => false,
            'linear' => null,
            'inverse' => null,
            'contractSize' => null,
            'taker' => $this->safe_number($this->safe_dict($this->fees, 'trading'), 'taker'),
            'maker' => $this->safe_number($this->safe_dict($this->fees, 'trading'), 'maker'),
            'expiry' => null,
            'expiryDatetime' => null,
            'strike' => null,
            'optionType' => null,
            'precision' => array(
                'amount' => $this->safe_number($market, 'quantityTickSize'),
                'price' => $this->safe_number($market, 'priceTickSize'),
            ),
            'limits' => array(
                'leverage' => array(
                    'min' => null,
                    'max' => null,
                ),
                'amount' => array(
                    'min' => null,
                    'max' => null,
                ),
                'price' => array(
                    'min' => null,
                    'max' => null,
                ),
                'cost' => array(
                    'min' => null,
                    'max' => null,
                ),
            ),
            'created' => null,
            'info' => $market,
        ));
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
         * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#book-market_id-snapshot
         * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#parsed-book-market_symbol-snapshot
         * @param {string} $symbol unified $symbol of the $market to fetch the order book for
         * @param {int} [$limit] the maximum amount of order book entries to return
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $marketInfo = $this->safe_dict($market, 'info');
        $symbolFromInfo = $this->safe_string($marketInfo, 'symbol');
        $request = array( 'market_symbol' => $symbolFromInfo );
        $response = $this->restMendelevPublicGetParsedBookMarketSymbolSnapshot (array_merge($request, $params));
        //
        // {
        //   "result":{
        //       "ticker_id":"BTCUSDC",
        //       "timestamp":1711544655331,
        //       "bids":array(
        //           array(
        //               70635.6,
        //               0.01
        //           )
        //       ),
        //       "asks":array(
        //           array(
        //               70661.8,
        //               0.1421
        //           )
        //       )
        //   }
        // }
        //
        $rawBids = $this->safe_list($this->safe_dict($response, 'result'), 'bids', array());
        $rawAsks = $this->safe_list($this->safe_dict($response, 'result'), 'asks', array());
        $rawOrderbook = array(
            'bids' => $rawBids,
            'asks' => $rawAsks,
        );
        $timestamp = $this->safe_timestamp($this->safe_dict($response, 'result'), 'timestamp') / 1000000;
        return $this->parse_order_book($rawOrderbook, $symbol, $timestamp, 'bids', 'asks');
    }

    public function parse_bids_asks($bidasks, int|string $priceKey = 0, int|string $amountKey = 1, int|string $countOrIdKey = 2): array {
        return $bidasks;
    }

    public function fetch_ticker(string $symbol, $params = array ()): array {
        /**
         * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
         * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#parsed-$tickers
         * @param {string} $symbol unified $symbol of the market to fetch the $ticker for
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $tickers = $this->fetch_tickers(array( $symbol ), $params);
        $ticker = $this->safe_value($tickers, $symbol, null);
        if ($ticker === null) {
            throw new BadSymbol($this->id . ' fetchTicker() $symbol ' . $symbol . ' not found');
        }
        return $ticker;
    }

    public function parse_ticker(array $ticker, ?array $market = null): array {
        //
        //       {
        //         ticker_id => "JTOUSDC",
        //         base_currency => "JTO",
        //         quote_currency => "USDC",
        //         $timestamp => 1713217334960,
        //         last_price => 2.6624,
        //         base_volume => 337.12,
        //         quote_volume => 961.614166,
        //         bid => 2.6627,
        //         ask => 2.6715,
        //         high => 3.0515,
        //         low => 2.6272,
        //         open => 2.8051,
        //       }
        //
        $timestamp = $this->safe_integer($ticker, 'timestamp');
        return $this->safe_ticker(array(
            'symbol' => $this->safe_string($market, 'symbol'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_number($ticker, 'high'),
            'low' => $this->safe_number($ticker, 'low'),
            'bid' => $this->safe_number($ticker, 'bid'),
            'bidVolume' => $this->safe_number($ticker, 'base_volume'),
            'ask' => $this->safe_number($ticker, 'ask'),
            'askVolume' => $this->safe_number($ticker, 'quote_volume'),
            'vwap' => null,
            'open' => $this->safe_number($ticker, 'open'),
            'close' => null,
            'last' => $this->safe_number($ticker, 'last_price'),
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $this->safe_number($ticker, 'base_volume'),
            'quoteVolume' => $this->safe_number($ticker, 'quote_volume'),
            'info' => $ticker,
        ), $market);
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()): array {
        /**
         * fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each $market
         * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#parsed-tickers
         * @param {string[]|null} $symbols unified $symbols of the markets to fetch the $ticker for, all $market tickers are returned if not assigned
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structures~
         */
        $meta = $this->fetch_market_meta($symbols);
        $symbols = $this->safe_list($meta, 'symbols');
        $response = $this->restMendelevPublicGetParsedTickers ($params);
        //
        //  {
        //     $result => array(
        //       array(
        //     ticker_id => "JTOUSDC",
        //     base_currency => "JTO",
        //     quote_currency => "USDC",
        //     timestamp => 1713216571697,
        //     last_price => 2.6731,
        //     base_volume => 333.66,
        //     quote_volume => 953.635304,
        //     bid => 2.6653,
        //     ask => 2.6761,
        //     high => 3.0515,
        //     low => 2.6272,
        //     open => 2.8231,
        //      ),
        //    ),
        //  }
        //
        $rawTickers = $this->safe_list($response, 'result', array());
        $result = array();
        for ($i = 0; $i < count($rawTickers); $i++) {
            $rawTicker = $rawTickers[$i];
            $marketId = str_replace('/', '', strtoupper($this->market_id($this->safe_string($rawTicker, 'ticker_id'))));
            $market = $this->market($marketId);
            $symbol = $this->safe_string($market, 'symbol');
            $ticker = $this->parse_ticker($rawTicker, $market);
            $result[$symbol] = $ticker;
        }
        return $this->filter_by_array_tickers($result, 'symbol', $symbols);
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches historical candlestick $data containing the open, high, low, and close price, and the volume of a $market
         * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#parsed-tickers
         * @param {string} $symbol unified $symbol of the $market to fetch OHLCV $data for
         * @param {string} $timeframe the length of time each candle represents
         * @param {int} [$since] timestamp in ms of the earliest candle to fetch
         * @param {int} [$limit] the maximum amount of candles to fetch
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {int[][]} A list of candles ordered, open, high, low, close, volume
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $market = $this->safe_dict($meta, 'market');
        $request = array(
            'duration' => $this->timeframes[$timeframe],
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        $response = $this->restMendelevPublicGetParsedTickers (array_merge($request, $params));
        $data = $this->safe_value($response, 'result', array());
        //
        //  {
        //     result => array(
        //       array(
        //     ticker_id => "JTOUSDC",
        //     base_currency => "JTO",
        //     quote_currency => "USDC",
        //     timestamp => 1713216571697,
        //     last_price => 2.6731,
        //     base_volume => 333.66,
        //     quote_volume => 953.635304,
        //     bid => 2.6653,
        //     ask => 2.6761,
        //     high => 3.0515,
        //     low => 2.6272,
        //     open => 2.8231,
        //      ),
        //    ),
        //  }
        //
        return $this->parse_ohlcvs($data, $market, $timeframe, $since, $limit);
    }

    public function parse_ohlcv($ohlcv, ?array $market = null): array {
        //
        //       {
        //         ticker_id => "JTOUSDC",
        //         base_currency => "JTO",
        //         quote_currency => "USDC",
        //         timestamp => 1713217334960,
        //         last_price => 2.6624,
        //         base_volume => 337.12,
        //         quote_volume => 961.614166,
        //         bid => 2.6627,
        //         ask => 2.6715,
        //         high => 3.0515,
        //         low => 2.6272,
        //         open => 2.8051,
        //       }
        //
        return array(
            $this->safe_timestamp($ohlcv, 'timestamp'),
            $this->safe_number($ohlcv, 'open'),
            $this->safe_number($ohlcv, 'high'),
            $this->safe_number($ohlcv, 'low'),
            $this->safe_number($ohlcv, 'last_price'),
            $this->safe_number($ohlcv, 'quote_volume'),
        );
    }

    public function fetch_balance($params = array ()): array {
        /**
         * query for balance and get the amount of funds available for trading or funds locked in $orders
         * @see https://cubexch.gitbook.io/cube-api/rest-iridium-api#users-positions
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a {@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure balance structure}
         */
        $this->load_markets();
        $response = $this->restIridiumPrivateGetUsersPositions ($params);
        $subaccountId = $this->safe_string($this->options, 'subaccountId');
        $balances = $this->safe_list($this->safe_dict($this->safe_dict($response, 'result'), $subaccountId), 'inner');
        $orders = $this->fetch_orders_all_markets();
        return $this->parse_balance(array(
            'orders' => $orders,
            'balances' => $balances,
        ));
    }

    public function parse_balance($response) {
        $orders = $this->safe_list($response, 'orders');
        $balances = $this->safe_list($response, 'balances');
        $openOrders = array();
        $filledUnsettledOrders = array();
        $allMarketsByNumericId = array();
        for ($i = 0; $i < $this->markets_by_id; $i++) {
            $marketArrayItem = is_array($this->markets_by_id) ? array_values($this->markets_by_id) : array()[$i];
            $market = $marketArrayItem[0];
            $marketInfo = $this->safe_dict($market, 'info');
            $marketNumericId = $this->safe_string($marketInfo, 'marketId');
            $allMarketsByNumericId[$marketNumericId] = $market;
        }
        $free = array();
        $used = array();
        $total = array();
        for ($i = 0; $i < count($balances); $i++) {
            $asset = $balances[$i];
            $assetAmount = intval($this->safe_string($asset, 'amount'));
            if ($assetAmount > 0) {
                $assetNumericId = $this->safe_string($asset, 'assetId');
                $currency = $this->currency($assetNumericId);
                $currencyPrecision = $this->safe_integer($currency, 'precision');
                $assetSymbol = $this->safe_string($currency, 'id');
                $total[$assetSymbol] = $assetAmount / 10 ** $currencyPrecision;
            }
        }
        for ($i = 0; $i < count($orders); $i++) {
            $order = $orders[$i];
            $orderStatus = $this->safe_string($order, 'status');
            if ($orderStatus === 'open') {
                $openOrders[] = $order;
            }
            if ($orderStatus === 'filled') {
                $isSettled = $this->safe_string($order, 'settled');
                if (!$isSettled) {
                    $filledUnsettledOrders[] = $order;
                }
            }
        }
        for ($i = 0; $i < count($openOrders); $i++) {
            $order = $openOrders[$i];
            $orderMarketId = $this->safe_string($order, 'marketId');
            $orderMarket = $this->safe_dict($allMarketsByNumericId, $orderMarketId);
            $orderSide = $this->safe_string($order, 'side');
            $orderBaseToken = $this->safe_string($orderMarket, 'base');
            $orderQuoteToken = $this->safe_string($orderMarket, 'quote');
            $orderAmount = $this->safe_integer($order, 'qty');
            $orderPrice = $this->safe_integer($order, 'price');
            $targetToken = '';
            $lotSize = 0;
            if ($orderSide === 'Ask') {
                $targetToken = $orderBaseToken;
                $lotSize = $this->safe_integer($this->safe_dict($orderMarket, 'info'), 'baseLotSize');
            } elseif ($orderSide === 'Bid') {
                $targetToken = $orderQuoteToken;
                $lotSize = $this->safe_integer($this->safe_dict($orderMarket, 'info'), 'quoteLotSize');
            }
            $targetCurrency = $this->currencies_by_id[$targetToken];
            $targetCurrencyPrecision = $this->safe_integer($targetCurrency, 'precision');
            $orderLockedAmount = 0;
            if ($orderSide === 'Ask') {
                $orderLockedAmount = $orderAmount * $lotSize / 10 ** $targetCurrencyPrecision;
            } elseif ($orderSide === 'Bid') {
                $orderLockedAmount = $orderAmount * $orderPrice * $lotSize / 10 ** $targetCurrencyPrecision;
            }
            if ($used[$targetToken] === null) {
                $used[$targetToken] = $orderLockedAmount;
            } else {
                $used[$targetToken] .= $orderLockedAmount;
            }
            $free[$targetToken] = $total[$targetToken] - $used[$targetToken];
        }
        $timestamp = $this->milliseconds();
        $result = array(
            'info' => $response,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'free' => $free,
            'used' => $used,
            'total' => $total,
        );
        for ($i = 0; $i < $total; $i++) {
            $assetSymbol = is_array($total) ? array_keys($total) : array()[$i];
            $assetBalances = array(
                'free' => $free[$assetSymbol],
                'used' => $used[$assetSymbol],
                'total' => $total[$assetSymbol],
            );
            $result[$assetSymbol] = $assetBalances;
        }
        return $this->safe_balance($result);
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()): array {
        /**
         * create a trade $order
         * @see https://cubexch.gitbook.io/cube-api/rest-osmium-api#$order
         * @param {string} $symbol unified $symbol of the $market to create an $order in
         * @param {string} $type 'market' or 'limit' or 'STOP_LOSS' or 'STOP_LOSS_LIMIT' or 'TAKE_PROFIT' or 'TAKE_PROFIT_LIMIT' or 'STOP'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much of you want to trade in units of the base currency
         * @param {float} [$price] the $price that the $order is to be fullfilled, in units of the quote currency, ignored in $market orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an ~@link https://docs.ccxt.com/#/?id=$order-structure $order structure~
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $marketId = $this->safe_string($meta, 'marketId');
        $market = $this->safe_dict($meta, 'market');
        $rawMarketId = $this->safe_integer($this->safe_dict($market, 'info'), 'marketId');
        $exchangePrice = $price * 100;
        $exchangeAmount = $amount * 100;
        $exchangeOrderType = null;
        if ($type === 'limit') {
            $exchangeOrderType = 0;
        } elseif ($type === 'market') {
            $exchangeOrderType = 1;
        } elseif ($type === 'MARKET_WITH_PROTECTION') {
            $exchangeOrderType = 2;
        } else {
            throw new InvalidOrder('OrderType was not recognized => ' . $type);
        }
        $exchangeOrderSide = null;
        if ($side === 'buy') {
            $exchangeOrderSide = 0;
        } elseif ($side === 'sell') {
            $exchangeOrderSide = 1;
        } else {
            throw new InvalidOrder('OrderSide was not recognized => ' . $side);
        }
        $timestamp = $this->milliseconds();
        $clientOrderIdFromParams = $this->safe_integer($params, 'clientOrderId');
        $clientOrderId = ($clientOrderIdFromParams === null) ? $timestamp : $clientOrderIdFromParams;
        $request = array(
            'clientOrderId' => $clientOrderId,
            'requestId' => $this->safe_integer($params, 'requestId', 1),
            'marketId' => $rawMarketId,
            'price' => $exchangePrice,
            'quantity' => $exchangeAmount,
            'side' => $exchangeOrderSide,
            'timeInForce' => $this->safe_integer($params, 'timeInForce', 1),
            'orderType' => $exchangeOrderType,
            'selfTradePrevention' => $this->safe_integer($params, 'selfTradePrevention', 0),
            'postOnly' => $this->safe_integer($params, 'postOnly', 0),
            'cancelOnDisconnect' => $this->safe_bool($params, 'cancelOnDisconnect', false),
        );
        $this->inject_sub_account_id($request, $params);
        $response = $this->restOsmiumPrivatePostOrder (array_merge($request, $params));
        $order = $this->safe_dict($this->safe_dict($response, 'result'), 'Ack');
        $exchangeOrderId = $this->safe_string($order, 'exchangeOrderId');
        $fetchedOrder = $this->fetch_raw_order($exchangeOrderId, $marketId);
        return $this->parse_order(
            array(
                'order' => $order,
                'fetchedOrder' => $fetchedOrder,
            ),
            $market
        );
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        /**
         * cancels an open order
         * @see https://cubexch.gitbook.io/cube-api/rest-osmium-api#order-1
         * @param {string} $id order $id
         * @param {string} $symbol unified $symbol of the $market the order was made in
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $marketId = $this->safe_string($meta, 'marketId');
        $market = $this->safe_dict($meta, 'market');
        $rawMarketId = $this->safe_integer($this->safe_dict($market, 'info'), 'marketId');
        $fetchedOrder = $this->fetch_raw_order($id, $marketId);
        if ($fetchedOrder === null) {
            $fetchedOrder = array();
        }
        $clientOrderId = intval($this->safe_string($fetchedOrder, 'clientOrderId'));
        $request = array(
            'clientOrderId' => $clientOrderId,
            'requestId' => $this->safe_integer($params, 'requestId'),
            'marketId' => $rawMarketId,
        );
        $this->inject_sub_account_id($request, $params);
        $response = $this->restOsmiumPrivateDeleteOrder (array_merge($request, $params));
        return $this->parse_order(
            array(
                'fetchedOrder' => $fetchedOrder,
                'cancellationResponse' => $response,
            ),
            $market
        );
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()) {
        /**
         * cancel all open orders
         * @see https://cubexch.gitbook.io/cube-api/rest-osmium-api#orders-1
         * @param {string} $symbol cube cancelAllOrders cannot setting $symbol, it will cancel all open orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $market = $this->safe_dict($meta, 'market');
        $rawMarkeId = $this->safe_integer($this->safe_dict($market, 'info'), 'marketId');
        $request = array(
            'marketId' => $rawMarkeId,
            'requestId' => $this->safe_integer($params, 'requestId', 1),
            'side' => $this->safe_integer($params, 'side', null),
        );
        $this->inject_sub_account_id($request, $params);
        // TODO wrong response, it is needed to return the cancelled orders!!!
        return $this->restOsmiumPrivateDeleteOrders (array_merge($request, $params));
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()): array {
        /**
         * fetches information on an $order made by the user
         * @see https://cubexch.gitbook.io/cube-api/rest-osmium-api#orders
         * @param {string} $symbol unified $symbol of the $market the $order was made in
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} An ~@link https://docs.ccxt.com/#/?$id=$order-structure $order structure~
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $market = $this->safe_dict($meta, 'market');
        $request = array();
        $this->inject_sub_account_id($request, $params);
        $rawResponse = $this->restOsmiumPrivateGetOrders (array_merge($request, $params));
        //
        //  {
        //      "result" => {
        //          "orders" => array(
        //              array(
        //                  "clientOrderId" => 1713422528124,
        //                  "exchangeOrderId" => 1295024967,
        //                  "marketId" => 100006,
        //                  "price" => 11000,
        //                  "orderQuantity" => 1,
        //                  "side" => 0,
        //                  "timeInForce" => 1,
        //                  "orderType" => 0,
        //                  "remainingQuantity" => 1,
        //                  "restTime" => 1713422528222471490,
        //                  "subaccountId" => 38393,
        //                  "cumulativeQuantity" => 0,
        //                  "cancelOnDisconnect" => false
        //              ),
        //              ...
        //          )
        //      }
        //  }
        //
        $result = $this->safe_list($this->safe_dict($rawResponse, 'result'), 'orders');
        $order = $this->parse_order(array( 'fetchedOrder' => $this->safe_value($result, 0) ), $market);
        if ($order !== null) {
            return $order;
        }
        throw new OrderNotFound('Order "' . $id . '" not found.');
    }

    public function fetch_raw_order($id, $symbol = null, $params = array ()) {
        /**
         * fetches information on an order made by the user
         * @see https://cubexch.gitbook.io/cube-api/rest-osmium-api#orders
         * @param {string} $symbol unified $symbol of the market the order was made in
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $request = array();
        $this->inject_sub_account_id($request, $params);
        $rawResponse = $this->restOsmiumPrivateGetOrders (array_merge($request, $params));
        //
        // {
        //    "result" => {
        //        "orders" => array(
        //            array(
        //                "clientOrderId" => 1713422528124,
        //                "exchangeOrderId" => 1295024967,
        //                "marketId" => 100006,
        //                "price" => 11000,
        //                "orderQuantity" => 1,
        //                "side" => 0,
        //                "timeInForce" => 1,
        //                "orderType" => 0,
        //                "remainingQuantity" => 1,
        //                "restTime" => 1713422528222471490,
        //                "subaccountId" => 38393,
        //                "cumulativeQuantity" => 0,
        //                "cancelOnDisconnect" => false
        //            ),
        //            ...
        //        )
        //    }
        // }
        //
        $result = $this->safe_list($this->safe_dict($rawResponse, 'result'), 'orders');
        return $this->safe_value($result, 0);
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch all unfilled currently open orders
         * @param {string} $symbol unified $market $symbol of the $market orders were made in
         * @param {int} [$since] the earliest time in ms to fetch orders for
         * @param {int} [$limit] the maximum number of order structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $market = $this->safe_market($this->safe_string($meta, 'marketId'), $this->safe_dict($meta, 'market'));
        $request = array();
        $this->inject_sub_account_id($request, $params);
        $response = $this->restIridiumPrivateGetUsersSubaccountSubaccountIdOrders (array_merge($request, $params));
        $rawOrders = $this->safe_list($this->safe_dict($response, 'result'), 'orders');
        return $this->parse_orders($rawOrders, $market, $since, $limit);
    }

    public function parse_orders(array $orders, ?array $market = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        //
        // the $value of $orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1' => array( ... ),
        //         'id2' => array( ... ),
        //         'id3' => array( ... ),
        //         ...
        //     }
        //
        // list
        //
        //     array(
        //         array( 'id' => 'id1', ... ),
        //         array( 'id' => 'id2', ... ),
        //         array( 'id' => 'id3', ... ),
        //         ...
        //     )
        //
        $results = array();
        if (gettype($orders) === 'array' && array_keys($orders) === array_keys(array_keys($orders))) {
            for ($i = 0; $i < count($orders); $i++) {
                $order = array_merge($this->parse_order($orders[$i], $market), $params);
                $results[] = $order;
            }
        } else {
            $entries = Object.entries ($orders);
            for ($i = 0; $i < count($entries); $i++) {
                $id = $entries[$i][0];
                $value = $entries[$i][1];
                $order = array_merge($this->parse_order(array_merge(array( 'id' => $id ), $value), $market), $params);
                $results[] = $order;
            }
        }
        $results = $this->sort_by($results, 'timestamp');
        $symbol = ($market !== null) ? $market['symbol'] : null;
        return $this->filter_by_symbol_since_limit($results, $symbol, $since, $limit);
    }

    public function parse_order($order, ?array $market = null) {
        // $transactionType = '';
        $fetchedOrder = $this->safe_dict($order, 'fetchedOrder');
        $mainOrderObject = array();
        if ($order['cancellationResponse'] !== null) {
            // $transactionType = 'cancellation';
            $mainOrderObject = $this->safe_dict($order, 'cancellationResponse');
        } else {
            // $transactionType = 'creation';
            $mainOrderObject = $this->safe_dict($order, 'order');
        }
        $timestampInNanoseconds = $this->safe_number($mainOrderObject, 'transactTime');
        $timestampInMilliseconds = $timestampInNanoseconds / 1000000;
        // $orderStatus = ''; // TODO fix !!!
        // if (is_array($fetchedOrder).'length === 0) ? array_keys($fetchedOrder).'length === 0) : array() {
        //     $orderStatus = 'canceled'
        // } else {
        //     $orderStatus = 'open'
        // }
        $result = array();
        // TODO Improve this part to reuse the original response from create, cancel, instead of relying in the fetched $order!!!
        if ($fetchedOrder && !(strlen($fetchedOrder) === 0)) {
            $exchangeOrderId = $this->safe_integer($fetchedOrder, 'exchangeOrderId');
            $clientOrderId = $this->safe_integer($fetchedOrder, 'clientOrderId');
            $orderSide = $this->safe_integer($fetchedOrder, 'side') === 0 ? 'buy' : 'sell';
            $price = $this->safe_integer($fetchedOrder, 'price') / 100;
            $symbol = $this->safe_string($market, 'base') . '/' . $this->safe_string($market, 'quote');
            $amount = $this->safe_integer($fetchedOrder, 'orderQuantity');
            $remainingAmount = $this->safe_integer($fetchedOrder, 'remainingQuantity');
            $filledAmount = $amount - $remainingAmount;
            $currency = '';
            if ($orderSide === 'buy') {
                $currency = $this->safe_string($market, 'base');
            } else {
                $currency = $this->safe_string($market, 'quote');
            }
            $orderType = '';
            $orderTypeRaw = $this->safe_integer($fetchedOrder, 'orderType');
            if ($orderTypeRaw === 0) {
                $orderType = 'limit';
            } elseif ($orderTypeRaw === 1) {
                $orderType = 'market';
            } elseif ($orderTypeRaw === 2) {
                $orderType = 'MARKET_WITH_PROTECTION';
            } else {
                throw new InvalidOrder('OrderType was not recognized while parsing => ' . $orderTypeRaw);
            }
            $timeInForce = '';
            $timeInForceRaw = $this->safe_integer($fetchedOrder, 'timeInForce');
            if ($timeInForceRaw === 0) {
                $timeInForce = 'IOC';
            } elseif ($timeInForceRaw === 1) {
                $timeInForce = 'GTC';
            } elseif ($timeInForceRaw === 2) {
                $timeInForce = 'FOK';
            } else {
                throw new InvalidOrder('TimeInForce was not recognized while parsing => ' . $timeInForceRaw);
            }
            $tradeFeeRatios = $this->safe_string($this->fees, 'trading');
            $rate = $orderSide === 'buy' ? $this->safe_string($tradeFeeRatios, 'maker') : $this->safe_string($tradeFeeRatios, 'taker');
            $decimalAmount = $amount / 100;
            $decimalFilledAmount = $filledAmount / 100;
            $decimalRemainingAmount = $remainingAmount / 100;
            $cost = $filledAmount * $price;
            $feeCost = $decimalAmount * floatval($rate);
            $result = array(
                'id' => $exchangeOrderId,
                'clientOrderId' => $clientOrderId,
                'datetime' => $this->iso8601($timestampInMilliseconds),
                'timestamp' => $timestampInMilliseconds,
                'lastTradeTimestamp' => $timestampInMilliseconds,
                'status' => 'open',
                'symbol' => $symbol,
                'type' => $orderType,
                'timeInForce' => $timeInForce,
                'side' => $orderSide,
                'price' => $price,
                'average' => 0.06917684,
                'amount' => $decimalAmount,
                'filled' => $decimalFilledAmount,
                'remaining' => $decimalRemainingAmount,
                'cost' => $cost,
                'trades' => array(),  // TODO => Implement trades
                'fee' => array(
                    'currency' => $currency, // a deduction from the asset property_exists($this, received) trade
                    'cost' => $feeCost,
                    'rate' => $rate,
                ),
                'info' => array(
                    'mainOrderObjetc' => $mainOrderObject,
                    'fetchedOrder' => $fetchedOrder,
                ),
            );
        }
        return $this->safe_order($result);
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetch all unfilled currently open orders
         * @param {string} $symbol unified $market $symbol of the $market orders were made in
         * @param {int} [$since] the earliest time in ms to fetch orders for
         * @param {int} [$limit] the maximum number of order structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $market = $this->safe_dict($meta, 'market');
        $request = array();
        $this->inject_sub_account_id($request, $params);
        $response = $this->restOsmiumPrivateGetOrders (array_merge($request, $params));
        $rawOrders = $this->safe_list($this->safe_dict($response, 'result'), 'orders');
        return $this->parse_orders($rawOrders, $market, $since, $limit);
    }

    public function fetch_orders_all_markets($since = null, $limit = null) {
        /**
         * fetch all orders from all markets
         * @param {string} symbol unified market symbol of the market orders were made in
         * @param {int} [$since] the earliest time in ms to fetch orders for
         * @param {int} [$limit] the maximum number of order structures to retrieve
         * @param {array} [params] extra parameters specific to the exchange API endpoint
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $request = array();
        $this->inject_sub_account_id($request, array());
        $response = $this->restIridiumPrivateGetUsersSubaccountSubaccountIdOrders (array_merge($request));
        $rawOrders = $this->safe_list($this->safe_dict($response, 'result'), 'orders');
        return $rawOrders;
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * get the list of most recent trades for a particular $symbol
         * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#book-market_id-recent-trades
         * @see https://cubexch.gitbook.io/cube-api/rest-mendelev-api#parsed-book-market_symbol-recent-trades
         * @param {string} $symbol unified $symbol of the $market to fetch trades for
         * @param {int} [$since] timestamp in ms of the earliest trade to fetch
         * @param {int} [$limit] the maximum number of trades to fetch
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} $params->lastId order id
         * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=public-trades trade structures~
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $market = $this->safe_dict($meta, 'market');
        $rawMarketId = $this->safe_string($this->safe_dict($market, 'info'), 'marketId');
        $rawMarketSymbol = $this->safe_string($this->safe_dict($market, 'info'), 'symbol');
        $request = null;
        $request = array(
            'market_id' => $rawMarketId,
        );
        $recentTradesResponse = $this->restMendelevPublicGetBookMarketIdRecentTrades (array_merge($request, $params));
        //
        // {
        //     "result":{
        //         "trades":array(
        //             array(
        //                 "tradeId":1192726,
        //                 "price":25730,
        //                 "aggressingSide":1,
        //                 "restingExchangeOrderId":775000423,
        //                 "fillQuantity":2048,
        //                 "transactTime":1710261845127064300,
        //                 "aggressingExchangeOrderId":775000298
        //             ),
        //             {
        //                 "tradeId":1192723,
        //                 "price":25730,
        //                 "aggressingSide":0,
        //                 "restingExchangeOrderId":775000298,
        //                 "fillQuantity":5000,
        //                 "transactTime":1710261844303742500,
        //                 "aggressingExchangeOrderId":774996895
        //             }
        //         )
        //     }
        // }
        //
        $request = array(
            'market_symbol' => $rawMarketSymbol,
        );
        $parsedRecentTradesResponse = $this->restMendelevPublicGetParsedBookMarketSymbolRecentTrades (array_merge($request, $params));
        //
        // {
        //     "result":{
        //         "ticker_id":"BTCUSDC",
        //         "trades":array(
        //             array(
        //                 "id":1106939,
        //                 "p":63565.6,
        //                 "q":0.01,
        //                 "side":"Ask",
        //                 "ts":1711153560907
        //             ),
        //             {
        //                 "id":1107084,
        //                 "p":63852.9,
        //                 "q":0.01,
        //                 "side":"Bid",
        //                 "ts":1711156552440
        //             }
        //         )
        //     }
        // }
        //
        $rawTrades = array(
            'trades' => $this->safe_list($this->safe_dict($recentTradesResponse, 'result'), 'trades'),
            'parsedTrades' => $this->safe_list($this->safe_dict($parsedRecentTradesResponse, 'result'), 'trades'),
        );
        return $this->parse_trades($rawTrades, $market);
    }

    public function parse_trades($rawTrades, $market = null) {
        $parsedTradesObject = $this->safe_dict($rawTrades, 'parsedTrades');
        $finalTrades = array();
        if ($parsedTradesObject && gettype($parsedTradesObject) === 'array') {
            $parsedTrades = is_array($parsedTradesObject) ? array_values($parsedTradesObject) : array();
            for ($i = 0; $i < count($parsedTrades); $i++) {
                $trade = $parsedTrades[$i];
                $finalTrades[] = $this->parse_trade($trade, $market);
            }
        }
        return $finalTrades;
    }

    public function parse_trade($trade, $market = null) {
        $timestampSeconds = 0;
        if ($trade['ts'] !== null) {
            $timestampSeconds = $this->safe_integer($trade, 'ts');
        } elseif ($trade['transactTime'] !== null) {
            $timestampNanoseconds = $trade['transactTime'];
            $timestampSeconds = $timestampNanoseconds / 1000000;
        }
        $datetime = $this->iso8601($timestampSeconds);
        $tradeSide = $this->safe_string($trade, 'side');
        $side = '';
        if ($tradeSide === 'Bid') {
            $side = 'buy';
        } elseif ($tradeSide === 'Ask') {
            $side = 'sell';
        }
        $marketSymbol = $this->safe_string($market, 'symbol');
        $price = floatval($this->safe_string($trade, 'p'));
        $amount = floatval($this->safe_string($trade, 'q'));
        return $this->safe_trade(array(
            'info' => $trade,
            'timestamp' => $timestampSeconds,
            'datetime' => $datetime,
            'symbol' => $marketSymbol,
            'id' => $this->safe_string($trade, 'id'),
            'order' => null,
            'type' => null,
            'takerOrMaker' => null,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'fee' => null,
            'fees' => array(
                array(
                    'cost' => null,
                    'currency' => null,
                    'rate' => null,
                ),
            ),
        ), $market);
    }

    public function fetch_trading_fee(string $symbol, $params = array ()): array {
        /**
         * fetch the trading fees for a $market
         * @see https://cubexch.gitbook.io/cube-api/rest-iridium-api#users-fee-estimate-$market-id
         * @param {string} $symbol unified $market $symbol
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=fee-structure fee structure~
         */
        $meta = $this->fetch_market_meta($symbol);
        $symbol = $this->safe_string($meta, 'symbol');
        $market = $this->safe_dict($meta, 'market');
        $rawMarketId = $this->safe_integer($this->safe_dict($market, 'info'), 'marketId');
        $request = array(
            'market_id' => $rawMarketId,
        );
        $response = $this->restIridiumPrivateGetUsersFeeEstimateMarketId (array_merge($request, $params));
        // {
        //     "result" => {
        //         "userKey" => "123e4567-e89b-12d3-a456-426614174000",
        //         "makerFeeRatio" => 0,
        //         "takerFeeRatio" => 0
        //     }
        // }
        return array(
            'info' => $response,
            'symbol' => $symbol,
            'maker' => $this->safe_number($this->safe_dict($response, 'result'), 'makerFeeRatio'),
            'taker' => $this->safe_number($this->safe_dict($response, 'result'), 'takerFeeRatio'),
            'percentage' => null,
            'tierBased' => null,
        );
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        throw new NotSupported($this->id . ' fetchMyTrades() is not supported yet');
    }

    public function fetch_closed_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        if ($this->has['fetchOrders']) {
            $orders = $this->fetch_orders($symbol, $since, $limit, $params);
            return $this->filter_by($orders, 'status', 'closed');
        }
        throw new NotSupported($this->id . ' fetchClosedOrders() is not supported yet');
    }

    public function fetch_status($params = array ()) {
        throw new NotSupported($this->id . ' fetchStatus() is not supported yet');
    }

    public function withdraw(string $code, float $amount, string $address, $tag = null, $params = array ()): array {
        /**
         * make a withdrawal
         * @see https://binance-docs.github.io/apidocs/spot/en/#withdraw-user_data
         * @param {string} $code unified currency $code
         * @param {float} $amount the $amount to withdraw
         * @param {string} $address the $address to withdraw to
         * @param {string} $tag
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
         */
        throw new NotSupported($this->id . ' withdraw() is not supported yet');
    }
}
